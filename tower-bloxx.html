<!DOCTYPE html>
<html lang="ar" dir="rtl">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Tower Bloxx üèóÔ∏è</title>
    <link href="https://fonts.googleapis.com/css2?family=Cairo:wght@400;600;700;900&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f0f23 100%);
            font-family: 'Cairo', sans-serif;
            overflow: hidden;
            position: relative;
        }

        /* Header */
        .game-header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 25px;
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            z-index: 100;
        }

        .back-btn {
            background: linear-gradient(135deg, #ffc107, #ff9800);
            color: #1a1a2e;
            border: none;
            padding: 10px 20px;
            border-radius: 25px;
            font-family: 'Cairo', sans-serif;
            font-weight: 700;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .back-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 20px rgba(255, 193, 7, 0.4);
        }

        .stats {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .stat {
            color: white;
            font-size: 1.1rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .stat-value {
            color: #ffc107;
            font-weight: 900;
            font-size: 1.3rem;
        }

        .lives {
            display: flex;
            gap: 5px;
        }

        .heart {
            font-size: 1.5rem;
            transition: all 0.3s ease;
        }

        .heart.lost {
            opacity: 0.3;
            transform: scale(0.8);
        }

        /* Game Canvas Container */
        .game-container {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            margin-top: 70px;
        }

        #gameCanvas {
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        }

        /* Start Screen */
        .start-screen,
        .game-over-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 200;
            animation: fadeIn 0.5s ease;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        .game-title {
            font-size: 3.5rem;
            font-weight: 900;
            color: #ffc107;
            text-shadow: 0 0 30px rgba(255, 193, 7, 0.5);
            margin-bottom: 20px;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.05);
            }
        }

        .game-subtitle {
            color: rgba(255, 255, 255, 0.7);
            font-size: 1.2rem;
            margin-bottom: 40px;
            text-align: center;
            max-width: 400px;
            line-height: 1.8;
        }

        .play-btn {
            background: linear-gradient(135deg, #ffc107, #ff9800);
            color: #1a1a2e;
            border: none;
            padding: 18px 60px;
            border-radius: 50px;
            font-family: 'Cairo', sans-serif;
            font-weight: 900;
            font-size: 1.5rem;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 10px 30px rgba(255, 193, 7, 0.3);
        }

        .play-btn:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 40px rgba(255, 193, 7, 0.5);
        }

        .instructions {
            color: rgba(255, 255, 255, 0.5);
            font-size: 0.9rem;
            margin-top: 30px;
            text-align: center;
        }

        /* Game Over */
        .final-score {
            font-size: 5rem;
            font-weight: 900;
            color: #ffc107;
            text-shadow: 0 0 40px rgba(255, 193, 7, 0.6);
            margin: 20px 0;
        }

        .final-height {
            color: rgba(255, 255, 255, 0.8);
            font-size: 1.3rem;
            margin-bottom: 10px;
        }

        .high-score {
            color: #4CAF50;
            font-size: 1.1rem;
            margin-bottom: 30px;
        }

        .new-record {
            animation: glow 1s infinite alternate;
        }

        @keyframes glow {
            from {
                text-shadow: 0 0 10px #4CAF50;
            }

            to {
                text-shadow: 0 0 30px #4CAF50, 0 0 50px #4CAF50;
            }
        }

        /* Perfect text */
        .perfect-text {
            position: fixed;
            font-size: 2rem;
            font-weight: 900;
            color: #4CAF50;
            text-shadow: 0 0 20px rgba(76, 175, 80, 0.8);
            pointer-events: none;
            animation: perfectAnim 1s forwards;
            z-index: 150;
        }

        @keyframes perfectAnim {
            0% {
                opacity: 1;
                transform: translateY(0) scale(1);
            }

            100% {
                opacity: 0;
                transform: translateY(-50px) scale(1.5);
            }
        }

        /* Combo counter */
        .combo {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 1.5rem;
            font-weight: 700;
            color: #E91E63;
            text-shadow: 0 0 15px rgba(233, 30, 99, 0.6);
            z-index: 150;
            opacity: 0;
            transition: all 0.3s ease;
        }

        .combo.active {
            opacity: 1;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .game-header {
                padding: 10px 15px;
            }

            .stat {
                font-size: 0.9rem;
            }

            .stat-value {
                font-size: 1.1rem;
            }

            .game-title {
                font-size: 2.5rem;
            }

            .game-subtitle {
                font-size: 1rem;
                padding: 0 20px;
            }

            .play-btn {
                padding: 15px 45px;
                font-size: 1.2rem;
            }

            .final-score {
                font-size: 4rem;
            }
        }
    </style>
</head>

<body>
    <!-- Header -->
    <div class="game-header">
        <a href="maintenance.html" class="back-btn">
            <span>‚Üê</span> ÿ±ÿ¨Ÿàÿπ
        </a>
        <div class="stats">
            <div class="stat">
                ÿßŸÑŸÜŸÇÿßÿ∑: <span class="stat-value" id="scoreDisplay">0</span>
            </div>
            <div class="stat">
                ÿßŸÑÿ∑Ÿàÿßÿ®ŸÇ: <span class="stat-value" id="floorDisplay">0</span>
            </div>
            <div class="lives" id="livesDisplay">
                <span class="heart">‚ù§Ô∏è</span>
                <span class="heart">‚ù§Ô∏è</span>
                <span class="heart">‚ù§Ô∏è</span>
            </div>
        </div>
    </div>

    <!-- Game Canvas -->
    <div class="game-container">
        <canvas id="gameCanvas"></canvas>
    </div>

    <!-- Combo Display -->
    <div class="combo" id="comboDisplay">üî• Combo x1</div>

    <!-- Start Screen -->
    <div class="start-screen" id="startScreen">
        <div class="game-title">üèóÔ∏è Tower Bloxx</div>
        <p class="game-subtitle">
            ÿßÿ®ŸÜŸä ÿ£ÿπŸÑŸâ ÿ®ÿ±ÿ¨ ŸÖŸÖŸÉŸÜ!
            <br>
            ÿßÿ∂ÿ∫ÿ∑ ŸÅŸä ÿßŸÑŸàŸÇÿ™ ÿßŸÑŸÖŸÜÿßÿ≥ÿ® ŸÑÿ•ÿ≥ŸÇÿßÿ∑ ÿßŸÑÿ®ŸÑŸàŸÉÿßÿ™ ÿ®ÿØŸÇÿ©
        </p>
        <button class="play-btn" id="startBtn">üéÆ ÿßÿ®ÿØÿ£ ÿßŸÑŸÑÿπÿ®</button>
        <p class="instructions">
            ÿßÿ∂ÿ∫ÿ∑ ÿπŸÑŸâ ÿßŸÑÿ¥ÿßÿ¥ÿ© ÿ£Ÿà ŸÖÿ≥ÿßŸÅÿ© Space ŸÑÿ•ÿ≥ŸÇÿßÿ∑ ÿßŸÑÿ®ŸÑŸàŸÉ
        </p>
    </div>

    <!-- Game Over Screen -->
    <div class="game-over-screen" id="gameOverScreen" style="display: none;">
        <div class="game-title">üèóÔ∏è ÿßŸÜÿ™Ÿáÿ™ ÿßŸÑŸÑÿπÿ®ÿ©!</div>
        <p class="final-height" id="finalHeight">ÿ®ŸÜŸäÿ™ 0 ÿ∑ÿßÿ®ŸÇ</p>
        <div class="final-score" id="finalScore">0</div>
        <p class="high-score" id="highScoreText">ÿ£ÿπŸÑŸâ ŸÜÿ™Ÿäÿ¨ÿ©: 0</p>
        <button class="play-btn" id="restartBtn">üîÑ ÿßŸÑÿπÿ® ŸÖÿ±ÿ© ÿ™ÿßŸÜŸäÿ©</button>
        <a href="maintenance.html" class="back-btn" style="margin-top: 20px;">
            ÿ±ÿ¨Ÿàÿπ ŸÑŸÑÿµŸÅÿ≠ÿ© ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ©
        </a>
    </div>

    <script>
        // Game Configuration
        const CONFIG = {
            canvasWidth: Math.min(400, window.innerWidth - 40),
            canvasHeight: Math.min(600, window.innerHeight - 120),
            blockWidth: 80,
            blockHeight: 30,
            swingSpeed: 0.04,
            fallSpeed: 8,
            colors: [
                '#E91E63', '#9C27B0', '#673AB7', '#3F51B5',
                '#2196F3', '#00BCD4', '#009688', '#4CAF50',
                '#8BC34A', '#CDDC39', '#FFC107', '#FF9800',
                '#FF5722', '#795548'
            ]
        };

        // Game State
        let canvas, ctx;
        let gameState = 'start'; // start, playing, gameOver
        let score = 0;
        let lives = 3;
        let combo = 0;
        let highScore = localStorage.getItem('towerBloxxHighScore') || 0;

        // Blocks
        let blocks = [];
        let currentBlock = null;
        let craneX = 0;
        let craneDirection = 1;
        let blockFalling = false;

        // Camera
        let cameraY = 0;
        let targetCameraY = 0;

        // Initialize
        function init() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');

            canvas.width = CONFIG.canvasWidth;
            canvas.height = CONFIG.canvasHeight;

            // Event listeners
            document.getElementById('startBtn').addEventListener('click', startGame);
            document.getElementById('restartBtn').addEventListener('click', startGame);

            // Drop block on click/tap/space
            canvas.addEventListener('click', dropBlock);
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                dropBlock();
            });
            document.addEventListener('keydown', (e) => {
                if (e.code === 'Space') {
                    e.preventDefault();
                    if (gameState === 'start') {
                        startGame();
                    } else if (gameState === 'gameOver') {
                        startGame();
                    } else {
                        dropBlock();
                    }
                }
            });

            // Start render loop
            requestAnimationFrame(gameLoop);
        }

        function startGame() {
            gameState = 'playing';
            score = 0;
            lives = 3;
            combo = 0;
            blocks = [];
            cameraY = 0;
            targetCameraY = 0;

            // Hide screens
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('gameOverScreen').style.display = 'none';

            // Update display
            updateDisplay();

            // Create first block (foundation)
            const foundationBlock = {
                x: CONFIG.canvasWidth / 2 - CONFIG.blockWidth / 2,
                y: CONFIG.canvasHeight - CONFIG.blockHeight - 50,
                width: CONFIG.blockWidth,
                height: CONFIG.blockHeight,
                color: CONFIG.colors[0]
            };
            blocks.push(foundationBlock);

            // Initialize crane
            craneX = 0;
            craneDirection = 1;

            // Create new swinging block
            createNewBlock();
        }

        function createNewBlock() {
            const colorIndex = blocks.length % CONFIG.colors.length;
            currentBlock = {
                x: 0,
                y: 50,
                width: blocks.length > 0 ? blocks[blocks.length - 1].width : CONFIG.blockWidth,
                height: CONFIG.blockHeight,
                color: CONFIG.colors[colorIndex],
                falling: false,
                velocity: 0
            };
            blockFalling = false;

            // Update camera target
            if (blocks.length > 5) {
                targetCameraY = (blocks.length - 5) * CONFIG.blockHeight;
            }
        }

        function dropBlock() {
            if (gameState !== 'playing' || blockFalling || !currentBlock) return;

            currentBlock.falling = true;
            blockFalling = true;
            currentBlock.velocity = CONFIG.fallSpeed;
        }

        function update() {
            if (gameState !== 'playing') return;

            // Smooth camera movement
            cameraY += (targetCameraY - cameraY) * 0.1;

            // Swing the crane
            if (!blockFalling && currentBlock) {
                craneX += CONFIG.swingSpeed * craneDirection * (CONFIG.canvasWidth - CONFIG.blockWidth);

                if (craneX >= CONFIG.canvasWidth - currentBlock.width) {
                    craneDirection = -1;
                } else if (craneX <= 0) {
                    craneDirection = 1;
                }

                currentBlock.x = craneX;
            }

            // Block falling
            if (currentBlock && currentBlock.falling) {
                currentBlock.y += currentBlock.velocity;
                currentBlock.velocity += 0.5; // Gravity

                const lastBlock = blocks[blocks.length - 1];
                const targetY = lastBlock.y - CONFIG.blockHeight;

                // Check if block reached the stack
                if (currentBlock.y >= targetY) {
                    currentBlock.y = targetY;
                    currentBlock.falling = false;

                    // Check alignment
                    const overlap = calculateOverlap(currentBlock, lastBlock);

                    if (overlap <= 0) {
                        // Missed completely
                        loseLife();
                    } else if (overlap >= lastBlock.width * 0.9) {
                        // Perfect placement!
                        perfectPlacement(currentBlock);
                    } else {
                        // Partial placement
                        partialPlacement(currentBlock, lastBlock, overlap);
                    }
                }
            }
        }

        function calculateOverlap(block1, block2) {
            const left1 = block1.x;
            const right1 = block1.x + block1.width;
            const left2 = block2.x;
            const right2 = block2.x + block2.width;

            const overlapLeft = Math.max(left1, left2);
            const overlapRight = Math.min(right1, right2);

            return overlapRight - overlapLeft;
        }

        function perfectPlacement(block) {
            // Align perfectly with last block
            const lastBlock = blocks[blocks.length - 1];
            block.x = lastBlock.x;
            block.width = lastBlock.width;

            blocks.push(block);
            combo++;
            score += 100 + (combo * 20);

            // Show perfect text
            showPerfectText();

            updateDisplay();
            createNewBlock();
        }

        function partialPlacement(block, lastBlock, overlap) {
            // Calculate new block dimensions
            const left = Math.max(block.x, lastBlock.x);
            const right = Math.min(block.x + block.width, lastBlock.x + lastBlock.width);

            block.x = left;
            block.width = right - left;

            // Check if too small
            if (block.width < 10) {
                loseLife();
                return;
            }

            blocks.push(block);
            combo = 0;
            score += Math.floor(50 * (overlap / CONFIG.blockWidth));

            updateDisplay();
            createNewBlock();
        }

        function loseLife() {
            lives--;
            combo = 0;
            updateDisplay();

            if (lives <= 0) {
                gameOver();
            } else {
                createNewBlock();
            }
        }

        function gameOver() {
            gameState = 'gameOver';

            // Update high score
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('towerBloxxHighScore', highScore);
                document.getElementById('highScoreText').classList.add('new-record');
                document.getElementById('highScoreText').textContent = 'üéâ ÿ±ŸÇŸÖ ŸÇŸäÿßÿ≥Ÿä ÿ¨ÿØŸäÿØ!';
            } else {
                document.getElementById('highScoreText').classList.remove('new-record');
                document.getElementById('highScoreText').textContent = `ÿ£ÿπŸÑŸâ ŸÜÿ™Ÿäÿ¨ÿ©: ${highScore}`;
            }

            document.getElementById('finalScore').textContent = score;
            document.getElementById('finalHeight').textContent = `ÿ®ŸÜŸäÿ™ ${blocks.length} ÿ∑ÿßÿ®ŸÇ`;
            document.getElementById('gameOverScreen').style.display = 'flex';
        }

        function showPerfectText() {
            const text = document.createElement('div');
            text.className = 'perfect-text';
            text.textContent = combo > 1 ? `üî• Perfect x${combo}!` : '‚ú® Perfect!';
            text.style.left = '50%';
            text.style.top = '40%';
            text.style.transform = 'translateX(-50%)';
            document.body.appendChild(text);

            setTimeout(() => text.remove(), 1000);
        }

        function updateDisplay() {
            document.getElementById('scoreDisplay').textContent = score;
            document.getElementById('floorDisplay').textContent = blocks.length;

            const hearts = document.querySelectorAll('#livesDisplay .heart');
            hearts.forEach((heart, i) => {
                if (i >= lives) {
                    heart.classList.add('lost');
                } else {
                    heart.classList.remove('lost');
                }
            });

            // Combo display
            const comboDisplay = document.getElementById('comboDisplay');
            if (combo > 1) {
                comboDisplay.textContent = `üî• Combo x${combo}`;
                comboDisplay.classList.add('active');
            } else {
                comboDisplay.classList.remove('active');
            }
        }

        function draw() {
            // Clear canvas
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw sky gradient
            const skyGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            skyGradient.addColorStop(0, '#0f0f23');
            skyGradient.addColorStop(1, '#16213e');
            ctx.fillStyle = skyGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw stars
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            for (let i = 0; i < 50; i++) {
                const x = (i * 37) % canvas.width;
                const y = (i * 53 + cameraY * 0.1) % canvas.height;
                ctx.beginPath();
                ctx.arc(x, y, 1, 0, Math.PI * 2);
                ctx.fill();
            }

            // Draw ground
            ctx.fillStyle = '#2d2d44';
            ctx.fillRect(0, canvas.height - 40 + cameraY, canvas.width, 40);

            // Draw blocks
            blocks.forEach((block, index) => {
                const drawY = block.y + cameraY;

                // Skip if out of view
                if (drawY > canvas.height || drawY + block.height < 0) return;

                // Block shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.fillRect(block.x + 3, drawY + 3, block.width, block.height);

                // Block gradient
                const gradient = ctx.createLinearGradient(block.x, drawY, block.x, drawY + block.height);
                gradient.addColorStop(0, block.color);
                gradient.addColorStop(1, shadeColor(block.color, -20));
                ctx.fillStyle = gradient;
                ctx.fillRect(block.x, drawY, block.width, block.height);

                // Block highlight
                ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.fillRect(block.x, drawY, block.width, 5);

                // Block border
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.lineWidth = 2;
                ctx.strokeRect(block.x, drawY, block.width, block.height);

                // Window lights (random pattern)
                if (block.width > 20) {
                    ctx.fillStyle = 'rgba(255, 255, 200, 0.6)';
                    const windows = Math.floor(block.width / 20);
                    for (let w = 0; w < windows; w++) {
                        if ((index + w) % 3 !== 0) {
                            const wx = block.x + 8 + w * 20;
                            const wy = drawY + 8;
                            ctx.fillRect(wx, wy, 8, 12);
                        }
                    }
                }
            });

            // Draw current block
            if (currentBlock) {
                const drawY = currentBlock.y + cameraY;

                // Block shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.fillRect(currentBlock.x + 3, drawY + 3, currentBlock.width, currentBlock.height);

                // Block
                const gradient = ctx.createLinearGradient(currentBlock.x, drawY, currentBlock.x, drawY + currentBlock.height);
                gradient.addColorStop(0, currentBlock.color);
                gradient.addColorStop(1, shadeColor(currentBlock.color, -20));
                ctx.fillStyle = gradient;
                ctx.fillRect(currentBlock.x, drawY, currentBlock.width, currentBlock.height);

                // Block highlight
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.fillRect(currentBlock.x, drawY, currentBlock.width, 5);

                // Block border
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.lineWidth = 2;
                ctx.strokeRect(currentBlock.x, drawY, currentBlock.width, currentBlock.height);

                // Draw crane rope if not falling
                if (!currentBlock.falling) {
                    ctx.strokeStyle = '#ffc107';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(currentBlock.x + currentBlock.width / 2, 0);
                    ctx.lineTo(currentBlock.x + currentBlock.width / 2, drawY);
                    ctx.stroke();

                    // Crane hook
                    ctx.fillStyle = '#ffc107';
                    ctx.beginPath();
                    ctx.arc(currentBlock.x + currentBlock.width / 2, drawY - 5, 6, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Draw guide line
            if (blocks.length > 0 && currentBlock && !currentBlock.falling) {
                const lastBlock = blocks[blocks.length - 1];
                ctx.strokeStyle = 'rgba(255, 193, 7, 0.3)';
                ctx.setLineDash([5, 5]);
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(lastBlock.x, 0);
                ctx.lineTo(lastBlock.x, canvas.height);
                ctx.moveTo(lastBlock.x + lastBlock.width, 0);
                ctx.lineTo(lastBlock.x + lastBlock.width, canvas.height);
                ctx.stroke();
                ctx.setLineDash([]);
            }
        }

        function shadeColor(color, percent) {
            const num = parseInt(color.replace('#', ''), 16);
            const amt = Math.round(2.55 * percent);
            const R = (num >> 16) + amt;
            const G = (num >> 8 & 0x00FF) + amt;
            const B = (num & 0x0000FF) + amt;
            return '#' + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 +
                (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 +
                (B < 255 ? B < 1 ? 0 : B : 255)).toString(16).slice(1);
        }

        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // Start when page loads
        window.addEventListener('load', init);

        // Handle resize
        window.addEventListener('resize', () => {
            CONFIG.canvasWidth = Math.min(400, window.innerWidth - 40);
            CONFIG.canvasHeight = Math.min(600, window.innerHeight - 120);
            if (canvas) {
                canvas.width = CONFIG.canvasWidth;
                canvas.height = CONFIG.canvasHeight;
            }
        });
    </script>
</body>

</html>